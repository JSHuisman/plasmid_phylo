source('../R/parsimony_functions.R')
plasmids_to_keep<- read_csv(paste0(base_dir,'/plasmids_to_keep.csv'))
plasmids_removed <- c('Col_MGD2', 'Col8282', 'IncB', 'IncX1', 'IncX3', 'p0111')
plasmids_to_keep <- plasmids_to_keep %>%
filter(! (name %in% plasmids_removed))
perm_parsimony <- read.csv(paste0(base_dir, '/Parsimony_plasmids_on_cgMLST_perm.csv'),
stringsAsFactors = FALSE)
real_parsimony <- read.csv(paste0(base_dir, '/Parsimony_plasmids_on_cgMLST_real.csv'),
stringsAsFactors = FALSE)
pars_dfs <- list('perm_parsimony' = perm_parsimony, 'real_parsimony' = real_parsimony)
plot_pars_densities(pars_dfs, set_ncol = 4)
compute_pars_pvalue_df <- function(pars_dfs, genes_list, method_list){
trees <- unique(pars_dfs$real_pars$tree)
pars_pvalue_df <- data.frame()
for (tree_type in trees){
for (sel_gene in genes_list){
for (sel_method in method_list){
pval <- pars_pvalue_from_df(pars_dfs, tree_type, sel_gene, sel_method)
pval_df <- data.frame('p_value' = pval, 'tree' = tree_type,
'method' = sel_method, 'gene' = sel_gene)
pars_pvalue_df <- rbind(pars_pvalue_df, pval_df)
}
}
}
return(pars_pvalue_df)
}
pars_pvalue_from_df <- function(pars_dfs, tree_type, sel_gene, sel_method){
perm_pars_vec <- pars_dfs$perm_parsimony %>%
filter(tree == tree_type, gene == sel_gene, method == sel_method) %>%
pull(parsimony)
real_pars_val <- pars_dfs$real_parsimony %>%
filter(tree == tree_type, gene == sel_gene, method == sel_method) %>%
pull(parsimony)
pars_density <- ecdf(perm_pars_vec)
return(pars_density(real_pars_val))
}
plas_pars_pvalue_df <- compute_pars_pvalue_df(pars_dfs, plasmids_to_keep$name, methods)  %>%
separate(method, into = c('seq_method', 'align_method'), sep = '_', extra = 'merge', remove = F)
plasmid_plot <- ggplot(data=plas_pars_pvalue_df, aes(y = p_value, x = gene) ) +
geom_boxplot() +
geom_point(aes(y = p_value, colour = seq_method, fill = align_method), shape = 21,
show.legend = TRUE, alpha = 1, size = 6, stroke = 3) +
geom_hline(mapping = aes(yintercept = 0.05), size = 1) +
scale_colour_manual(values = c('red', 'black', 'grey', 'white')) +
scale_fill_manual(values = c('red', 'black', 'grey', 'white')) +
facet_wrap(vars(gene), nrow = 1, scales = 'free_x',
labeller = labeller(gene = c("Col_MG828" = "ColMG828",
"Col156"="Col156", "ColRNAI"="ColRNAI",
"IncFIA" ="IncFIA", "IncFIB_AP001918" = "IncFIB",
"IncFIC_FII"="IncFIC_FII",
"IncFII_pRSB107"= "IncFII", "IncI1"="IncI1") )) +
labs(x = 'Plasmid', y = 'P-value', colour = 'Sequencing method',
fill = 'Assembly method') +
theme_classic() +
theme(axis.text= element_text(size=20),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.title = element_text(size=24, face="bold"),
axis.title.x = element_blank(),
legend.position = 'bottom',
legend.text = element_text(size = 22),
legend.title = element_text(size = 25),
panel.grid = element_blank(),
panel.spacing = unit(2, "lines"),
strip.background = element_blank(),
strip.text = element_text(size=20)) +
guides(colour = guide_legend(nrow = 2, override.aes=list(size = 5) ),
fill = guide_legend(nrow = 2, override.aes=list(colour = NA, stroke = 2) ))
plasmid_plot
tip_data <- read_tip_data('PB_Unicycler')
check_gene_presence <- function(x){as.numeric(any(x != ''))}
# MAKE SURE THE COMBINED SUMMARIES INCLUDE MISC!!!
read_tip_data <- function(method, base_dir = '/Volumes/Extreme_SSD/sequences/Summaries'){
file_path <- paste0(base_dir, '/', method, '/summaries/combined.csv')
tip_data <- read.csv(file_path, stringsAsFactors = F)
compressed_tip_data <- tip_data %>%
group_by(sample) %>%
summarise_at(vars(-group_cols()), check_gene_presence)
return(compressed_tip_data)
}
tip_data <- read_tip_data('PB_Unicycler')
tip_data
genes <- sort(colSums(tip_data[,12:74]))
res_genes <- genes[setdiff(seq_along(genes), grep('Col|Inc|p0111', names(genes)))]
res_genes
sel_res_genes <- names(res_genes[res_genes > 5 & res_genes < 21])
spec_res_genes <- c("aadA5", "blaCTX.M.1", "blaCTX.M.27","blaCTX.M.15","blaTEM.1B", "sul1", "sul2")
sorted_spec_res_genes <- names(sort(res_genes[spec_res_genes]))
sel_res_genes <- union(sel_res_genes, spec_res_genes)
sel_res_genes
sel_res_genes <- c("aadA5", "aph.3....Ib", "dfrA17", "aac.6...Ib.cr","blaOXA.1",
"blaTEM.1B","catB3", "sul2", "tet.34.", "blaCTX.M.15",
"mph.A.", "ant.3....Ia", "blaCTX.M.1", "blaCTX.M.27", "sul1")
perm_parsimony <- read.csv(paste0(base_dir, '/Parsimony_resgenes_on_cgMLST_perm.csv'),
stringsAsFactors = FALSE)
real_parsimony <- read.csv(paste0(base_dir, '/Parsimony_resgenes_on_cgMLST_real.csv'),
stringsAsFactors = FALSE)
pars_dfs <- list('perm_parsimony' = perm_parsimony, 'real_parsimony' = real_parsimony)
subset_pars_dfs <- filter_pars_dfs(pars_dfs, "tree == 'cgMLST'")
filter_pars_dfs <- function(pars_dfs, filter_expr){
subset_perm_pars_dfs <- pars_dfs$perm_parsimony %>%
filter(eval(parse(text=filter_expr)))
subset_real_pars_dfs <- pars_dfs$real_parsimony %>%
filter(eval(parse(text=filter_expr)))
subset_pars_dfs <- list(perm_parsimony = subset_perm_pars_dfs,
real_parsimony = subset_real_pars_dfs)
return(subset_pars_dfs)
}
subset_pars_dfs <- filter_pars_dfs(pars_dfs, "tree == 'cgMLST'")
plot_pars_densities(subset_pars_dfs, set_ncol = 5,
max_pars = floor(dim(tip_data)[1]/2),
adjust = 3, dot_dist = 0.2)
subset_pars_dfs <- filter_pars_dfs(pars_dfs, 'gene %in% sorted_spec_res_genes')
plot_resgene_scan(subset_pars_dfs, sorted_spec_res_genes, x_var = 'norm_pars',
method_labels = method_labels)
ggsave(paste0("../../figures/Parsimony_resgenes_dist_overview.pdf"),
plot=last_plot(), width = 15, height = 12, device="pdf")
pars_pvalue_df <- compute_pars_pvalue_df(pars_dfs, sorted_spec_res_genes, methods)
ggplot(data=pars_pvalue_df, aes(x=method)) +
theme(axis.text=element_text(size=24), axis.title=element_text(size=24,face="bold")) +
scale_x_discrete(labels = method_labels) +
geom_point(aes(y = p_value, colour = tree), show.legend = TRUE, alpha = 1, size = 3) +
geom_hline(mapping = aes(yintercept = 0.05)) +
facet_wrap(facets = vars(gene), nrow = 1, ncol = 7) +
labs(x = 'Assembly method', y = 'P-value', colour = 'Tree type') +
theme(legend.position = 'bottom') +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size=20))
# Violin-PLOT
res_pars_pvalue_df <- pars_pvalue_df %>%
separate(method, into = c('seq_method', 'align_method'), sep = '_', extra = 'merge', remove = F) %>%
mutate(tree_recode = recode(tree,
"cgMLST" = "Canu", #"Illumina",
"IncI1" = "SPAdes", #"NP",
"IncFIA" = "Unicycler", #"PB",
"IncFII_pRSB107" = "Canu_Hybrid_Polished"))
res_pars_pvalue_df %>%
filter(gene == 'blaCTX.M.27',
tree == 'IncFIA')
res_plot <- ggplot(data=res_pars_pvalue_df, aes(y = p_value, x = tree,
group = interaction(gene, tree))) +
geom_violin(aes(fill = tree_recode), scale = 'width', width = 0.5, show.legend = F) +
geom_point(aes(colour = seq_method, fill = align_method), shape = 21,
show.legend = TRUE, alpha = 1, size = 6, stroke = 3) +
facet_wrap(vars(gene), nrow = 1) +
scale_colour_manual(values = c('red', 'black', 'grey', 'transparent')) +
scale_fill_manual(values = c('red', 'black', 'grey', 'white')) +
geom_hline(mapping = aes(yintercept = 0.05), size = 1) +
theme_classic() +
labs(x = 'Resistance gene', y = 'P-value', colour = 'Sequencing method',
fill = 'Assembly method', shape = 'Tree') +
theme(axis.text= element_text(size=20),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.title = element_text(size=24, face="bold"),
axis.title.x = element_blank(),
legend.position = 'none',
panel.grid = element_blank(),
panel.spacing = unit(2, "lines"),
strip.background = element_blank(),
strip.text = element_text(size=20))
res_plot
plasmid_plot + res_plot +
plot_layout(ncol = 1) + #heights=c(1, 1), guides = "collect") +
plot_annotation(tag_levels = 'A') &
theme(plot.tag = element_text(size = 30))
### Combine both ####################################
library(patchwork)
plasmid_plot + res_plot +
plot_layout(ncol = 1) + #heights=c(1, 1), guides = "collect") +
plot_annotation(tag_levels = 'A') &
theme(plot.tag = element_text(size = 30))
pars_dfs <- compute_multitree_pars_dfs(methods, sel_res_genes, c("IncI1", "IncFIA", "IncFII_pRSB107"), cgmlst = TRUE)
###### Gene Presence #####################################
check_gene_presence <- function(x){as.numeric(any(x != ''))}
read_tip_data <- function(method, base_dir = '../../data'){
file_path <- paste0(base_dir, '/gene_summaries/', method, '.csv')
tip_data <- read.csv(file_path, stringsAsFactors = F)
compressed_tip_data <- tip_data %>%
group_by(sample) %>%
summarise_at(vars(-group_cols()), check_gene_presence)
return(compressed_tip_data)
}
####### Get parsimony permutation #########################
# Used in compute_pars_for_gene()
get_parsimony_permutations <- function(tree, tip_states, n_perm = 1000){
n_total_perm <- multinom(tip_states, counts = FALSE, useDouble = FALSE)
n_true_perm <- min(n_total_perm, n_perm)
n_pres = sum(tip_states)
permuted_tip_states <- matrix(data = 0, nrow = n_true_perm, ncol = length(tip_states))
for(i in 1:n_true_perm){
permuted_tip_states[i,sample(1:length(tip_states), n_pres)] <- 1
}
colnames(permuted_tip_states) <- tree$tip.label
parsimony.v <- vector(mode='numeric', length=dim(permuted_tip_states)[1])
for (i_row in 1:dim(permuted_tip_states)[1]){
data <- as.phyDat(as.factor(permuted_tip_states[i_row,]))
parsimony.v[i_row]<- parsimony(tree, data)
}
return(parsimony.v)
}
# ##### Compute Parsimony Dataframes ###############################
compute_pars_for_gene <- function(method, tree, gene){
tip_data <- read_tip_data(method)
no_data_tips <- setdiff(tree$tip.label, tip_data$sample)
if(length(no_data_tips)>0){
extra_df <- as.data.frame(matrix(data = 0, nrow = length(no_data_tips), ncol = dim(tip_data)[2],
dimnames = list(samples = no_data_tips, attributes = colnames(tip_data))))
extra_df['sample'] <- no_data_tips
tip_data <- rbind(tip_data, extra_df)
}
state_of_interest_id <- grep(gene, sub('\\.', '_', colnames(tip_data))) #paste0(gene, '$')
if (length(state_of_interest_id)>1){
print(paste0('Gene: ', gene, ' Method: ', method))
}
tip_states <- unlist(sapply(tree$tip.label,
function(x){unname(tip_data[tip_data$sample == x, state_of_interest_id[1]]) }))
max_pars = min(sum(tip_states), length(tip_states) - sum(tip_states))
if (any(is.na(tip_states))){
return(list(perm = data.frame(), real = data.frame()))
} else {
parsimony.v <- get_parsimony_permutations(tree, tip_states)
method_pars_df <- data.frame('parsimony' = parsimony.v, 'norm_pars' = parsimony.v/max_pars,
'method' = method, 'gene' = gene)
real_pars <- parsimony(tree, as.phyDat(as.factor(tip_states)))
real_method_pars_df <- data.frame('parsimony' = real_pars, 'norm_pars' = real_pars/max_pars,
'method' = method, 'gene' = gene)
return(list(perm = method_pars_df, real = real_method_pars_df))
}
}
compute_pars_dfs <- function(method_list, gene_list, plasmid = NULL){
parsimony_df <- data.frame()
real_parsimony_df <- data.frame()
for (gene in gene_list){
for (method in method_list){
if (is.null(plasmid)){
# from tree_reading_functions
tree <- read_cgmlst_tree(method)
tree_type = 'cgMLST'
} else {
# from tree_reading_functions
tree <- read_plasmid_mcc_tree(method, plasmid)
tree_type = plasmid
}
new_pars = compute_pars_for_gene(method, tree, gene)
new_pars$perm['tree'] <- tree_type
new_pars$real['tree'] <- tree_type
parsimony_df <- rbind(parsimony_df, new_pars$perm)
real_parsimony_df <- rbind(real_parsimony_df, new_pars$real)
}
}
return(list(perm_parsimony = parsimony_df, real_parsimony = real_parsimony_df))
}
compute_multitree_pars_dfs <- function(method_list, gene_list, plasmid_list, cgmlst = TRUE){
if (cgmlst){
pars_dfs <- compute_pars_dfs(methods, gene_list, plasmid = NULL)
} else {
pars_dfs <- data.frame()
}
for (plasmid in plasmid_list){
new_pars_dfs <- compute_pars_dfs(methods, gene_list, plasmid = plasmid)
pars_dfs$perm_parsimony <- rbind(pars_dfs$perm_parsimony, new_pars_dfs$perm_parsimony)
pars_dfs$real_parsimony <- rbind(pars_dfs$real_parsimony, new_pars_dfs$real_parsimony)
}
return(pars_dfs)
}
###########################################################
filter_pars_dfs <- function(pars_dfs, filter_expr){
subset_perm_pars_dfs <- pars_dfs$perm_parsimony %>%
filter(eval(parse(text=filter_expr)))
subset_real_pars_dfs <- pars_dfs$real_parsimony %>%
filter(eval(parse(text=filter_expr)))
subset_pars_dfs <- list(perm_parsimony = subset_perm_pars_dfs,
real_parsimony = subset_real_pars_dfs)
return(subset_pars_dfs)
}
# #### Compute p value dfs ##################################
pars_pvalue_from_df <- function(pars_dfs, tree_type, sel_gene, sel_method){
perm_pars_vec <- pars_dfs$perm_parsimony %>%
filter(tree == tree_type, gene == sel_gene, method == sel_method) %>%
pull(parsimony)
real_pars_val <- pars_dfs$real_parsimony %>%
filter(tree == tree_type, gene == sel_gene, method == sel_method) %>%
pull(parsimony)
pars_density <- ecdf(perm_pars_vec)
return(pars_density(real_pars_val))
}
compute_pars_pvalue_df <- function(pars_dfs, genes_list, method_list){
trees <- unique(pars_dfs$real_pars$tree)
pars_pvalue_df <- data.frame()
for (tree_type in trees){
for (sel_gene in genes_list){
for (sel_method in method_list){
pval <- pars_pvalue_from_df(pars_dfs, tree_type, sel_gene, sel_method)
pval_df <- data.frame('p_value' = pval, 'tree' = tree_type,
'method' = sel_method, 'gene' = sel_gene)
pars_pvalue_df <- rbind(pars_pvalue_df, pval_df)
}
}
}
return(pars_pvalue_df)
}
### Plot parsimony plots ##################################
plot_pars_densities <- function(pars_dfs, set_ncol, max_pars = 12,
adjust = 3, dot_dist = 0.05){
set_nrow = ceiling(length(unique(pars_dfs$perm_parsimony$gene))/set_ncol)
ggplot(data=pars_dfs$perm_parsimony, aes(x=parsimony)) +
geom_density(aes(x=parsimony, colour = method), fill = "white", alpha = .3, adjust = adjust) +
theme(axis.text=element_text(size=24), axis.title=element_text(size=24,face="bold")) +
scale_x_continuous(breaks = pretty(c(0.5, max_pars+0.5), n = 5), limits = c(0.5, max_pars+0.5)) +
scale_colour_discrete(labels = method_labels) +
geom_point(data = pars_dfs$real_parsimony, position = position_stack(vjust = 1), show.legend = FALSE,
alpha = .8, size = 3,
mapping = aes(x = parsimony, colour = method, y = rep(dot_dist, dim(pars_dfs$real_parsimony)[1]) )) +
facet_wrap(facets = vars(gene), nrow = set_nrow, ncol = set_ncol) +
labs(x = 'Parsimony score', y = 'Density', colour = 'Assembly method') +
theme(legend.position = 'bottom') + guides(colour = guide_legend(nrow = 3))
}
plot_resgene_scan <- function(pars_dfs, sorted_spec_res_genes, x_var = 'norm_pars',
facet_row_var = 'method', facet_col_var = 'gene',
colour_var = 'tree', colour_name = 'Tree type',
max_pars = 12, method_labels = method_labels){
pars_dfs$perm_parsimony$gene <- factor(pars_dfs$perm_parsimony$gene, levels = sorted_spec_res_genes)
pars_dfs$real_parsimony$gene <- factor(pars_dfs$real_parsimony$gene, levels = sorted_spec_res_genes)
pars_plot <- ggplot(data=pars_dfs$perm_parsimony, aes(x= get(x_var) ) ) +
geom_density(aes(x = get(x_var), colour = tree), alpha = .3, fill = "white", adjust = 3, show.legend = FALSE) +
geom_point(data = pars_dfs$real_parsimony,
mapping = aes(x = get(x_var), colour = get(colour_var),
y = rep(0.2, dim(pars_dfs$real_parsimony)[1]) ),
position = position_stack(vjust = 1),
alpha = .8, size = 3) +
geom_vline(data = pars_dfs$real_parsimony, show.legend = FALSE,
mapping = aes(xintercept = get(x_var), colour = get(colour_var) ) ) +
facet_grid(rows = vars(get(facet_row_var)), cols = vars(get(facet_col_var)),
labeller = labeller( .rows = method_labels)) +
theme(axis.text=element_text(size=24), axis.title=element_text(size=24,face="bold"),
legend.position = 'bottom') +
labs(x = 'Parsimony score', y = 'Density', colour = colour_name) +
theme_classic() #+ guides(colour = guide_legend(nrow = 1))
if (x_var == 'parsimony'){
pars_plot <- pars_plot +
scale_x_continuous(breaks = pretty(c(0.5, max_pars+0.5), n = 5), limits = c(0.5, max_pars+0.5))
}
return(pars_plot)
}
pars_dfs <- compute_multitree_pars_dfs(methods, sel_res_genes, c("IncI1", "IncFIA", "IncFII_pRSB107"), cgmlst = TRUE)
source('../R/tree_reading_functions.R')
pars_dfs <- compute_multitree_pars_dfs(methods, sel_res_genes, c("IncI1", "IncFIA", "IncFII_pRSB107"), cgmlst = TRUE)
subset_pars_dfs <- filter_pars_dfs(pars_dfs, "tree == 'cgMLST'")
plot_pars_densities(subset_pars_dfs, set_ncol = 5,
max_pars = floor(dim(tip_data)[1]/2),
adjust = 3, dot_dist = 0.2)
pars_pvalue_df <- compute_pars_pvalue_df(pars_dfs, sorted_spec_res_genes, methods)
# Violin-PLOT
res_pars_pvalue_df <- pars_pvalue_df %>%
separate(method, into = c('seq_method', 'align_method'), sep = '_', extra = 'merge', remove = F) %>%
mutate(tree_recode = recode(tree,
"cgMLST" = "Canu", #"Illumina",
"IncI1" = "SPAdes", #"NP",
"IncFIA" = "Unicycler", #"PB",
"IncFII_pRSB107" = "Canu_Hybrid_Polished"))
res_plot <- ggplot(data=res_pars_pvalue_df, aes(y = p_value, x = tree,
group = interaction(gene, tree))) +
geom_violin(aes(fill = tree_recode), scale = 'width', width = 0.5, show.legend = F) +
geom_point(aes(colour = seq_method, fill = align_method), shape = 21,
show.legend = TRUE, alpha = 1, size = 6, stroke = 3) +
facet_wrap(vars(gene), nrow = 1) +
scale_colour_manual(values = c('red', 'black', 'grey', 'transparent')) +
scale_fill_manual(values = c('red', 'black', 'grey', 'white')) +
geom_hline(mapping = aes(yintercept = 0.05), size = 1) +
theme_classic() +
labs(x = 'Resistance gene', y = 'P-value', colour = 'Sequencing method',
fill = 'Assembly method', shape = 'Tree') +
theme(axis.text= element_text(size=20),
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
axis.title = element_text(size=24, face="bold"),
axis.title.x = element_blank(),
legend.position = 'none',
panel.grid = element_blank(),
panel.spacing = unit(2, "lines"),
strip.background = element_blank(),
strip.text = element_text(size=20))
res_plot
library(ggplot2)
#library(reshape2)
library(dplyr)
library(tidyverse)
library("viridis")
library(RColorBrewer)
source('../R/Log_file_analysis_functions.R')
theme_set(theme_light(base_size = 24, base_family = 'sans'))
################################################################
base_dir='../../data'
###########################################################
library('treespace')
plasmids_to_keep <- read_csv('../../data/plasmids_to_keep.csv')
methods = c('Illumina_SPAdes', 'NP_Canu', 'NP_Canu_Hybrid_Polished', 'NP_SPAdes', 'NP_Unicycler',
'PB_Canu', 'PB_Canu_Hybrid_Polished', 'PB_SPAdes', 'PB_Unicycler')
method_labels = c('Illumina-SPAdes', 'NP-Canu', 'NP-Canu-Hybrid', 'NP-SPAdes-Hybrid', 'NP-Unicycler-Hybrid',
'PB-Canu', 'PB-Canu-Hybrid', 'PB-SPAdes-Hybrid', 'PB-Unicycler-Hybrid')
names(method_labels) <- methods
plasmid_path <- function(method, plasmid = 'Col_MG828'){
path <- paste0(base_dir, '/plasmid_trees/', method, '_', plasmid, '_subset.trees')
# by selecting subset, we exclude the fixed set
return(path)
}
read_trees <- function(x){
trees <- try(read.nexus(plasmid_path(x, plasmid = plasmid))[seq(900, 9001, 100)])
if (class(trees) == 'try-error'){
trees <- NULL
}
return(trees)
}
ntrees = length(seq(900, 9001, 100))
for (plasmid in plasmids_to_keep$name){
plasmid_trees <- lapply(methods, FUN = read_trees)
plasmid_ntips <- sapply(1:length(plasmid_trees), function(i){length(plasmid_trees[[i]]$STATE_0$tip.label)})
methods_included <- rep(1:9,1)[plasmid_ntips == median(plasmid_ntips)]
if (median(plasmid_ntips) > 0){
all_plasmid_trees <- plasmid_trees[[methods_included[1]]]
for (i in methods_included[2:length(methods_included)]){
all_plasmid_trees <- c(all_plasmid_trees, plasmid_trees[[i]])
}
if (all_plasmid_trees[[1]]$Nnode > 2){
test <- findGroves(all_plasmid_trees, nf = 2, nclust = 2)
#scree.size determines size of histogram inset
# d in upper corner indicates distance between grid lines; can add ylim/xlim to change
p <- plotGroves(test$treespace$pco, groups = sort(rep(methods[methods_included], ntrees)),
type="ellipse", scree.size = 0)#, lab.show=TRUE)
print(p)
#plotGroves(test, type="ellipse", lab.show=TRUE)
quartz.save(paste0("../../figures/", plasmid,
"_", alignment_method, "_treespace.pdf"), type = 'pdf', dpi = 100)
rm(test)
}
}
}
for (plasmid in plasmids_to_keep$name){
plasmid_trees <- lapply(methods, FUN = read_trees)
plasmid_ntips <- sapply(1:length(plasmid_trees), function(i){length(plasmid_trees[[i]]$STATE_0$tip.label)})
methods_included <- rep(1:9,1)[plasmid_ntips == median(plasmid_ntips)]
if (median(plasmid_ntips) > 0){
all_plasmid_trees <- plasmid_trees[[methods_included[1]]]
for (i in methods_included[2:length(methods_included)]){
all_plasmid_trees <- c(all_plasmid_trees, plasmid_trees[[i]])
}
if (all_plasmid_trees[[1]]$Nnode > 2){
test <- findGroves(all_plasmid_trees, nf = 2, nclust = 2)
#scree.size determines size of histogram inset
# d in upper corner indicates distance between grid lines; can add ylim/xlim to change
p <- plotGroves(test$treespace$pco, groups = sort(rep(methods[methods_included], ntrees)),
type="ellipse", scree.size = 0)#, lab.show=TRUE)
print(p)
#plotGroves(test, type="ellipse", lab.show=TRUE)
quartz.save(paste0("../../figures/", plasmid,
"_treespace.pdf"), type = 'pdf', dpi = 100)
rm(test)
}
}
}
library(ggplot2)
library(reshape2)
library(dplyr)
library(tidyr)
library(readr)
library("viridis")
library(RColorBrewer)
source('../R/Log_file_analysis_functions.R')
source('../R/tree_comparison_functions.R')
theme_set(theme_light(base_size = 24, base_family = 'sans'))
################################################################
input_folder='../../data'
methods = c('Illumina_SPAdes', 'NP_Canu', 'NP_Canu_Hybrid_Polished', 'NP_SPAdes', 'NP_Unicycler',
'PB_Canu', 'PB_Canu_Hybrid_Polished', 'PB_SPAdes', 'PB_Unicycler')
method_labels = c('Illumina-SPAdes', 'NP-Canu', 'NP-Canu-Hybrid', 'NP-SPAdes-Hybrid', 'NP-Unicycler-Hybrid',
'PB-Canu', 'PB-Canu-Hybrid', 'PB-SPAdes-Hybrid', 'PB-Unicycler-Hybrid')
names(method_labels) <- methods
clade_df <- read.csv(paste0(input_folder, '/plasmid_clade_comparison.csv'), stringsAsFactors = FALSE)
clade_df_y <- clade_df %>%
select(Clade, clade_prob_y, method_y, alignment_method, plasmid)
colnames(clade_df_y) <- c("Clade", "clade_prob", "method", "alignment_method", "plasmid")
clade_df_x <- clade_df %>%
select(Clade, clade_prob_x, method_x, alignment_method, plasmid)
colnames(clade_df_x) <- c("Clade", "clade_prob", "method", "alignment_method", "plasmid")
joint_clade_df <- rbind(clade_df_y, clade_df_x)
joint_clade_df <- unique(joint_clade_df)
for (alignment in c("roary")){
for (plasmid in unique(joint_clade_df$plasmid)){
clade_heatmap_by_plasmid(joint_clade_df, plasmid, alignment, method_labels)
for (output_folder in c('../../figures/')){
ggsave(paste0(output_folder,'/', plasmid,'_', alignment, '_heatmap.pdf'), plot=last_plot(),
width = 15, height = 20,
device="pdf")
}
}
}
clade_df <- concat_clade_probs(input_folder, methods)
clade_df <- concat_clade_probs("/Volumes/Extreme_SSD/sequences/Summaries/dated_tree_comparison/", methods)
write_csv(clade_df, '../../data/chrom_clade_comparison.csv')
#generated by concat_clade_probs() on individual clade probability files
clade_df <- read_csv('../../data/chrom_clade_comparison.csv')
clade_df_y <- clade_df %>%
select(Clade, clade_prob_y, method_y)
colnames(clade_df_y) <- c("Clade", "clade_prob", "method")
clade_df_x <- clade_df %>%
select(Clade, clade_prob_x, method_x)
colnames(clade_df_x) <- c("Clade", "clade_prob", "method")
joint_clade_df <- rbind(clade_df_y, clade_df_x)
joint_clade_df <- unique(joint_clade_df)
(clade_map <- clade_heatmap(joint_clade_df, method_labels))
ggsave("../../figures/cgmlst_heatmap.pdf",
plot=clade_map, device="pdf")
